%% bare_jrnl_compsoc.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE Computer
%% Society journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/




% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
% The Computer Society usually requires 10pt for submissions.
%
\documentclass[10pt,journal,letterpaper,twoside]{IEEEtran}
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[12pt,journal,compsoc]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
%\else
  % normal IEEE
  \usepackage{cite}
%\fi
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.
%
% Note that some packages require special options to format as the Computer
% Society requires. In particular, Computer Society  papers do not use
% compressed citation ranges as is done in typical IEEE papers
% (e.g., [1]-[4]). Instead, they list every citation separately in order
% (e.g., [1], [2], [3], [4]). To get the latter we need to load the cite
% package with the nocompress option which is supported by cite.sty v4.0
% and later. Note also the use of a CLASSOPTION conditional provided by
% IEEEtran.cls V1.7 and later.





% *** GRAPHICS RELATED PACKAGES ***
%
%\ifCLASSINFOpdf
%  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
%\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
%\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
\let\latexvec=\vec
%\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{relsize}
\let\vec=\latexvec
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
% \usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


% \usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
% \ifCLASSOPTIONcompsoc
% \usepackage[tight,normalsize,sf,SF]{subfigure}
% \else
% \usepackage[tight,footnotesize]{subfigure}
% \fi
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. Computer Society papers
% use a larger font and \sffamily font for their captions, hence the
% additional options needed under compsoc mode. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.


%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false]{caption}
%  \usepackage[font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false]{caption}
%  \usepackage[font=footnotesize]{subfig}
%\fi
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley and Jeff Goldberg.
% This package may be useful when used in conjunction with IEEEtran.cls'
% captionsoff option. Some IEEE journals/societies require that submissions
% have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.3.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% For subfigure.sty:
% \let\MYorigsubfigure\subfigure
% \renewcommand{\subfigure}[2][\relax]{\MYorigsubfigure[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat/subfig command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/endfloat/
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a 
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.


% Other packages
\usepackage{becs}

\usepackage{listings}
\lstset{%
  basicstyle=\scriptsize,
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  xleftmargin=2em
}

% Theorem-like environments
\newtheorem{definition}{Definition}
\newtheorem{exampleb}{Example}

% \subsubsubsection - really!?
\newcommand{\subsubsubsection}[1]{\medskip\par\emph{#1:}}

% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{color}
%\usepackage{subfigure}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Swarm coordination through perimeter detection}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%
%
%\IEEEcompsocitemizethanks is a special \thanks that produces the bulleted
% lists the Computer Society journals use for "first footnote" author
% affiliations. Use \IEEEcompsocthanksitem which works much like \item
% for each affiliation group. When not in compsoc mode,
% \IEEEcompsocitemizethanks becomes like \thanks and
% \IEEEcompsocthanksitem becomes a line break with idention. This
% facilitates dual compilation, although admittedly the differences in the
% desired content of \author between the different types of papers makes a
% one-size-fits-all approach a daunting prospect. For instance, compsoc 
% journal papers have the author affiliations above the "Manuscript
% received ..."  text while in non-compsoc journals this is reversed. Sigh.

\author{Neil Eliot, David Kendall, Michael Brockway
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem
N.~Eliot
D.~Kendall
M.~Brockway are from Northumbria University, UK}
\thanks{}}

% note the % following the last \IEEEmembership and also \thanks - 
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
% 
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
\markboth{IEEE Transactions on Automatic Control}%
{N.~Eliot: Swarm coordination through perimeter detection}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
% 
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.



% The publisher's ID mark at the bottom of the page is less important with
% Computer Society journal papers as those publications place the marks
% outside of the main text columns and, therefore, unlike regular IEEE
% journals, the available text space is not reduced by their presence.
% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2007 IEEE}
% or like this to get the Computer Society new two part style.
%\IEEEpubid{\makebox[\columnwidth]{\hfill 0000--0000/00/\$00.00~\copyright~2007 IEEE}%
%\hspace{\columnsep}\makebox[\columnwidth]{Published by the IEEE Computer Society\hfill}}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark (Computer Society jorunal
% papers don't need this extra clearance.)




% for Computer Society papers, we must declare the abstract and index terms
% PRIOR to the title within the \IEEEcompsoctitleabstractindextext IEEEtran
% command as these need to go into the title area created by \maketitle.
\IEEEcompsoctitleabstractindextext{%
\begin{abstract}
%\boldmath
This paper identifies the effect a \textit{destination vector} has upon the motion of a swarm. Three coordination techniques are applied to a swarm and metrics are used to identify the effects. The three coordination techniques are: full perimeter detection, where only edge based agents will have a \textit{destination vector} applied. Partial perimeter detection, where a subset of the perimeter agents are detected and finally all agents in the swarm having a \textit{destination vector} applied. For all the experiments the base parameters of the swarm are fixed ensuring that the only variable will be the \textit{destination vector} that is applied by the coordinating agents. This process allows the impact of the algorithms to be isolated and compared. Section~\ref{sec:AlternateBias1}~discusses the potential variations to the base parameters and the effects this has on controlling the impact of the weightings.
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the journal you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals frown on math
% in the abstract anyway. In particular, the Computer Society does
% not want either math or citations to appear in the abstract.

% Note that keywords are not normally used for peer review papers.
\begin{IEEEkeywords}
Swarming, Swarm Dynamics, Mobile Sensor Networks, Algorithms.
\end{IEEEkeywords}}


% make the title area
\maketitle


% To allow for easy dual compilation without having to reenter the
% abstract/keywords data, the \IEEEcompsoctitleabstractindextext text will
% not be used in maketitle, but will appear (i.e., to be "transported")
% here as \IEEEdisplaynotcompsoctitleabstractindextext when compsoc mode
% is not selected <OR> if conference mode is selected - because compsoc
% conference papers position the abstract like regular (non-compsoc)
% papers do!
\IEEEdisplaynotcompsoctitleabstractindextext
% \IEEEdisplaynotcompsoctitleabstractindextext has no effect when using
% compsoc under a non-conference mode.


% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

%% \section{Introduction}
\section{Baseline specification}
To allow an analysis of each algorithm's effect on a swarm a baseline measurement of `background' variance (jitter) is identified. The baseline measurement provides a comparative data set for the experiments. The baseline data set is for a static swarm (no destination vector) with the same internal parameters.

\textit{Assumption 1:} The swarm used for the experiments consists of 200 agents randomly distributed~(Figure~\ref{fig:SampleSwarm200-1}).\\ 
\textit{Assumption 2:} The field effects and bias will be set as shown in~Figure~\ref{tab:DynamicPhysics1} with the weight adjuster $k_d = 0$ for the baseline.\\
\textit{Assumption 3:} All destination based experiments will have the weight adjuster set to $k_d = 100$.

\begin{figure}
\begin{center}
\includegraphics[width=8cm]{figures/SampleSwarm200-1}
\end{center}
\caption[Sample swarm 200 agents initial state]{Sample swarm 200 agents initial state (\textit{screen shot from simulator})\label{fig:SampleSwarm200-1}}
\end{figure}

\begin{table}
\begin{center}
\begin{tabular}{| p{1.5cm} | c | p{3.5cm} |}
\hline
\bf Weight \bf Component & \bf Hexagonal & \bf Description \\ \hline
Sample Rate & 100 & ms - Unit sampling interval\\  \hline
$k_c$ & 5 & weight adjuster for cohesion vector\\  \hline
$k_r$ & 15 & weight adjuster for repulsion  vector\\  \hline
$k_d$ & 0/100 & weight adjuster for destination vector 0 for static baseline 100 for destination based\\  \hline
Neighbour Distance & 70 & units\\  \hline
Agent Boundary & 80 & units\\  \hline
Speed & 20 & units/s\\  \hline
\end{tabular}\caption{Swarm Weighted Model} \label{tab:DynamicPhysics1}
\end{center}
\end{table}

The results for the baseline experimental swarm are shown in~Figures~\ref{coord:BaselineMagnitude1} and~\ref{coord:BaselineDistance1}. The metrics used are the distance \cite{NIM:09} and resultant inter-agent magnitudes (\textit{inter-agent vector}).

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineMagnitude1}
\end{center}
\caption{Baseline internal movement - magnitude\label{coord:BaselineMagnitude1}}
\end{figure}

Figure~\ref{coord:BaselineMagnitude1} shows the magnitude between $t_0$ and approximately $t_{48}$ dominated by repulsion ($|k_rv_r| > |k_cv_c|$). This indicates that the swarm is undergoing a rapid expansion as the bias within the swarm shows a high level of repulsion. Between approximately $t_{48}$ and $t_{100}$ the magnitude is positive but rising which indicates the swarm is cohesive and will remain a cohesive unit but it is still expanding. At approximately $t_{110}$ the swarm has completed it's expansion and has reached a settled state with the `background' movement maintaining the swarm's structure with $|k_rv_r| < |k_cv_c|$. The residual `jitter' is at its minimum for the configuration and the agent distribution is at its optimum for the cohesion and repulsion settings. The resultant $|k_rv_r| < |k_cv_c|$ is due to the cohesion field being larger than the repulsion field which prevents the swarm `breaking up'. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineDistance1}
\end{center}
\caption{Baseline internal movement - distance\label{coord:BaselineDistance1}}
\end{figure}

Figure~\ref{coord:BaselineDistance1} shows the internal movement and the deviation from the mean for the swarm based on the inter-agent distances. There is no \textit{destination vector} applied so all internal movement is being generated by the cohesion and repulsion vectors. The swarm is initially in a chaotic state but once the agents have expanded a stable hexagonal formation evolves. Figure~\ref{coord:BaselineDistance1} shows the first 30s of the simulation which is sufficient time for the swarm to `settle' and transform to its most stable state. Due to the metric only showing inter-agent distances it is not possible to determine if the swarm will remain cohesive.

The centroid path for the baseline swarm is shown in~FIgure~\ref{coord:SwarmPathBaseline1}. Due to there being no \textit{destination vector} for the swarm the centroid changes positions based on the inter-agent positional changes caused by the \textit{interaction vectors}. These changes are the result of each agents attempting to attain a state of equilibrium within their `clusters'.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmPathBaseline}
\end{center}
\caption{Baseline swarm path\label{coord:SwarmPathBaseline1}}
\end{figure}

These baseline measurements are used to identify the changes that occur in the structure of a swarm when changes are made to the weightings of the field effects, the number of coordination agents and the \textit{destination vector} weighting.

\section{Destination vector application}
Many mechanisms can be used to influence a swarm to travel in a specific direction. These mechanisms generally involve the use of sensors such as magnetometers or GPS's to achieve a directional coordinate \cite{SG:15,TG:12}. 

This thesis aims to produce algorithms that will reduce the number of active sensors that are needed for the directional coordination of a swarm. When reducing the number of active sensors the algorithms must maintain sufficient coordination of agents to influence the swarm's direction and therefore create an overall \textit{destination vector} to a swarms movement. Reducing the number of active sensors will reduce the net energy usage of the sensors and potentially increase the sensors viable lifetime. Another aspect of the algorithms is that they should minimise the internal disturbance (jitter) created by the \textit{destination vector}.

There are two distinct approaches to configuring agents: all the agents are configured identically (homogeneous swarm) or the agents are in a selection of different configurations (heterogeneous swarm)~\cite{BS:13}. 

The following assumptions are made in this thesis:

\textit{Assumption 1:} All agents are identical (homogeneous) but are able select subsystems as necessary and adopt different roles depending upon the algorithm being used to coordinate the swarm. \\
\textit{Assumption 2:} As the swarm progresses towards a destination the role of an agent can change such that all the agents are identical in construct but they can enable and disable sensors as necessary. This will allow agents within the swarm to self promote to the coordinator role should a set of conditions arise.\\
\textit{Assumption 3:} All agent in the swarm are autonomous and each agent has its own power supply. 

Reducing the usage of sensors will reduce the net power consumption of the swarm and increase the time that an agent can be a part of a swarm. If the purpose of the swarm is reconnaissance then the reduction in energy usage may allow a longer traversal time, or allow the swarm to travel further. As agents in the swarm will use there resources at different rates some agents may be lost due to resource exhaustion. The algorithms should therefore be resilient to this.

\section{Swarm destination vector}
The following assumptions are made in this thesis:

\textit{Assumption 1:} The direction of the swarm is based upon having a fixed goal that is known to all the agents. \\
\textit{Assumption 2:} The goal is migrated towards based on a simulated GPS signal and the bias $k_d$ is applied to the \textit{destination vector} to influence the movement of the agents. 

The swarm's destination is established by the coordinator agents influencing the non-coordinator agents. This influence is applied through the coordinators proximity to non-coordinator agents (cohesion). Coordinator agents are identified by a set of conditions. The conditions are the activators for the coordinator identification algorithms.

\section{Identifying the coordinator role}
For an agent to change its role from a standard agent to a coordinator there needs to an algorithm that identifies a set of conditions to trigger the change. This same algorithm also triggers an agent to revert to being a standard agent. The coordinator selection algorithm is separate from the agent coordination algorithms that determine cohesion and repulsion.

In this thesis three algorithms are presented and compared. In the first algorithm, all agents have the role of a coordinator permanently. This will be referred to as the all-agent algorithm. The other two mechanisms employ a selection criteria to identify if the simulated GPS sensor should be enabled. These two algorithms are: full-perimeter detection and the partial perimeter detection. Partial perimeter detection will be referred to as the basic-count algorithm.

There are many other ways in which the coordinator role could be established such as randomly enabling a GPS for a set period of time or oscillating the role on and off but they are beyond the scope of this thesis.

\section{Monolithic swarm - (all-agent)} 
In a monolithic swarm \cite{BS:13} the propagation towards the goal is achieved by all the agents using a GPS signal to give each agents' movement a \textit{direction vector} towards a required goal. There is no selection criteria and no computational overhead for the agents.

Figure~\ref{reduced:Monolithic1} shows a screen shot from the swarm simulator with all agents GPS's enabled. This can be seen as the agents highlighted with a ring around them. The small `tail' on each agent is the \textit{movement vector}.

\begin{figure}
\begin{center}
\includegraphics[width=6cm]{figures/Monolithic2}
\end{center}
\caption[Monolithic agents]{Monolithic agents (Circles indicate all agents are using GPS, \textit{screen shot from simulator}) \label{reduced:Monolithic1}}
\end{figure}

\subsection{Baseline and effect of no perimeter detection\label{section:compareBaselineNoPerimeter}}
To identify the effect of the all-agents algorithm the simulation is executed using the same parameters as the baseline swarm with the added \textit{destination vector} on all the agents. The effect of introducing this bias on the swarms internal characteristics is shown in~Figures~\ref{reduced:BaselineAllAgentsMag1} and~\ref{reduced:BaselineAllAgentsDist1}.
%BASELINE-ALLAGENTS-MAG.py
\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllAgentsMag1}
\end{center}
\caption{Baseline/All agents comparison \textit{inter-agent vector} magnitude\label{reduced:BaselineAllAgentsMag1}}
\end{figure}

Figure~\ref{reduced:BaselineAllAgentsMag1} shows the effect on the \textit{inter-agent vector} magnitude of the swarm: the average resultant magnitude is lower than the baseline. This is due to there being a greater distribution of \textit{inter-agent vector} magnitudes from the disturbance caused by the \textit{destination vector} on all of the agents and the swarm is therefore less cohesive. The graph also shows that there is a higher variation from the mean; again this is due to the change in the bias of all the agents. The agents are moving towards a goal and are therefore not moving to an equilibrium distribution. Figure~\ref{reduced:BaselineAllAgentsMag1}~also shows that the \textit{direction vector} increases the time it takes for the swarm to distribute the agents and although the deviation diminishes the swarm cannot overcome the \textit{direction vector's} effect and the swarm appears chaotic.
%BASELINE-ALLAGENTS-DIST.py
\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllAgentsDist1}
\end{center}
\caption{Baseline/All agents comparison (distance)\label{reduced:BaselineAllAgentsDist1}}
\end{figure}

Figure~\ref{reduced:BaselineAllAgentsDist1} shows the effect on the inter-agent distances. The average distance is lower than the baseline. This effect is caused by the \textit{direction vector} reducing the effect of the repulsion field. The agents therefore compress slightly due to the cohesion.

A curious effect of having all the GPS sensors enabled is that as the swarm approaches the destination there is an increased compression effect and the internal disturbance increases. This is the result of the agents `pulling' in a cone effect. The agents paths converge on the destination~Figure~\ref{reduced:ConicalPath}. This effect is caused by the number of agents being effected by a \textit{direction vector}. This effect is less identifiable if a swarm's target is at a greater distance.  

\begin{figure}
\begin{center}
\includegraphics[width=7cm]{figures/ConicalPath}
\end{center}
\caption{Conical destination trajectories\label{reduced:ConicalPath}}
\end{figure}

This effect can be seen in both the magnitudes shown in~Figure~\ref{reduced:BaselineAllAgentsMag2} and in the distances shown in~Figure~\ref{reduced:BaselineAllAgentsDist2} which both show the averages initially decreasing but then increasing again as the swarm approaches the destination. This is accompanied by a greater standard deviation caused by the \textit{direction vector} affecting the priority of the swarm as agents are drawn to the destination reducing the effect of the \textit{inter-agent vectors} creating stable structures.
%BASELINE-ALLAGENTS-MAG.py
\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllAgentsMag2}
\end{center}
\caption[Baseline/All agents magnitude comparison]{Baseline/All agents \textit{inter-agent vector} magnitude comparison (60 seconds)\label{reduced:BaselineAllAgentsMag2}}
\end{figure}
%BASELINE-ALLAGENTS-DIST.py
\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllAgentsDist2}
\end{center}
\caption{Baseline/All agents distance comparison (60 seconds)\label{reduced:BaselineAllAgentsDist2}}
\end{figure}

\section{Simple multifaceted swarm (basic-count)} 
In a simple multifaceted swarm the propagation towards the goal is achieved by generating a \textit{destination vector} for an agent when the agent conforms to a simple counting rule. This \textit{destination vector} is obtained by using the agent's GPS to identify its current coordinate and generating a vector from that coordinate to a specific destination point. This rule creates a subset of agents that apply a local \textit{direction vector} to their movement. This has the effect of creating a directional effect on the whole swarm. The aggregate \textit{direction vector} magnitude of the swarm is less than that produced when all agents apply a \textit{direction vector}. This reduction is further diluted by agents without the \textit{direction vector} calculating a \textit{movement vector} to an equilibrium position. This change in the aggregate \textit{direction vector} will impact on a swarm's `jitter'. This is discussed in more detail in~Section~\ref{sec:AlternateBias1}. With there only being a limited number of peripheral agents invoking their GPS signal there will also be a net reduction in the energy usage of the swarm~(Figure~\ref{reduced:EnergyReductionGPS}).

A swarm with the appropriate field effects will propagate towards hexagons made from a central agent and six neighbours. A swarm can be influenced by its surroundings, which involves the interaction of other agents (as neighbours) and obstacles which can cause a compression of the agents. Compression can also occur during the stabilisation phase of a swarm. These situations can cause an agent to have less than 6 neighbours but still be surrounded. A general rule therefore to detect a rudimentary boundary of a hexagonal swarm is to calculate the number of neighbours an agent has. If the total is less than five ($nbr(b) < 5$) then there is a high probability that the agent is either in a void within the swarm or on an external perimeter. If an agent is on a perimeter or a void the it should enable its GPS and become a coordinator and provide a directional bias to the swarm via its \textit{direction vector}. This coordinator role affects the immediate neighbours \textit{movement vector} through cohesion/repulsion~(Figure~\ref{reduced:SimpleMulti12}). This simple detection algorithm allows a directional bias to be induced into a swarm with minimal computational impact on the coordinator agents.

\subsection{Simple multifaceted algorithm}
The mechanism to enable a coordinator agent is to count the number of neighbours that an agent has~(Algorithm~\ref{algo:neighbourDetect}). This process is already part of the cohesion and repulsion calculations.

\begin{figure}
\begin{algorithmic}[1]
\Procedure{CheckVisibility}{$b,S$}
%\tcc{$b$ is an agent and $S$ is a set of agents}
%\tcc{The set of agent could be provided by an omni directional camera or a set of ultrasonic sensors}
\State $N \longleftarrow \emptyset$\;
\For{$b^{'}$ in $S$}
  \If{$length(bb') < D_{b}$}
     \State $N \longleftarrow N \cup \{b\}$
  \EndIf
\EndFor
%\tcc{$N$ is a set of Bots $b_1,b_2,\ldots,b_n$}
\State\textbf{return} $N$
\EndProcedure
\end{algorithmic}
\caption[Neighbour Detection]{nbr(b)}
\label{algo:neighbourDetect}
\end{figure}

\subsection{Basic-count effect\label{section:compareBaselineBasicCount1}}
Figure~\ref{reduced:BaselineBasicCountMag1} and \ref{reduced:BaselineBasicCountDist1} show the comparison of the baseline swarm against the goal-based swarm with reduced GPS usage. Both graphs show that the settling period of the swarm from the chaotic state is very much in line with the settling period of the baseline swarm. This is due to the algorithms effect when the swarm is initially compressed. The neighbour count prevents any agents from being coordinators ($|nbr(b)| > 5$). This is supported by the propagation of the coordinator role in Figure~\ref{fig:SwarmNeighbourCount}. The swarm therefore acts in a similar manner to the baseline. As the simulation progresses the swarm settles into a condition that is similar to baseline with a higher deviation and lower mean resultant \textit{inter-agent vector}. This is due to there being a \textit{direction vector} which impacts on the coordinator agents and propagates to the non-coordinator agents through proximity. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineBasicCountMag1}
\end{center}
\caption{Baseline/basic-count magnitude potential comparison\label{reduced:BaselineBasicCountMag1}}
\end{figure}

Figure~\ref{reduced:BaselineBasicCountMag1} shows that initially the average \textit{inter-agent vector magnitude} can be seen to follow the same trend as the baseline. This is expected as the algorithms selection criteria is such that no GPS sensors are enabled when the swarm is compressed and the agents will have a neighbour count well above the trigger level for the coordinator role. When the swarm expands sufficiently the trigger level is met by some agents and there is a gradual increase in the number of coordinators. This also creates a greater distribution of resultant \textit{interaction vectors}, shown as the change in the standard deviation. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineBasicCountDist1}
\end{center}
\caption{Baseline and basic-count distance comparison\label{reduced:BaselineBasicCountDist1}}
\end{figure}
 
Figure~\ref{reduced:BaselineBasicCountDist1} shows that the impact of the directional bias allows the agents to move closer together. This increased closeness reduces the effective area coverage of the swarm. 

Figure~\ref{reduced:SimpleMulti12} shows a screen shot of the simulator using the basic-count algorithm. The reduction in GPS usage is limited to edge based agents of the swarm. Some perimeter agents are not identified as a coordinator due to the number of neighbours they have being $\geq5$. These agents tend to be indented on a perimeter edge.

\begin{figure}
\begin{center}
\includegraphics[width=6cm]{figures/SimpleMulti2}
\end{center}
\caption[Simple multifaceted agents]{Simple multifaceted agents (\textit{screen shot from simulator})\label{reduced:SimpleMulti12}}
\end{figure}

\section{Complex multifaceted swarm (full-perimeter)}\label{sec:complexMulti} 
A complex multifaceted swarm is based upon the full detection of perimeters in a swarm. There are two perimeters that can be detected, convex and concave~\cite{MD:09,MJ:08}. Convex perimeters enclose agents and concave perimeters create voids. Figures~\ref{concave:VoidPerimeter1} and \ref{concave:VoidPerimeter2} show these two perimeter types. The concave perimeter is highlighted in red and the convex perimeter is highlighted in green

\begin{figure}
\begin{center}
	 \includegraphics[width=4cm]{figures/PerimeterBots1}\label{concave:VoidPerimeter1}
\end{center}
\caption{Void and perimeter}
\label{concave:VoidPerimeter1}
\end{figure}

\begin{figure}
\begin{center}
	 \includegraphics[width=4cm]{figures/PerimeterBots2}\label{concave:VoidPerimeter2}
\end{center}
\caption{Multiple perimeters}
\label{concave:VoidPerimeter2}
\end{figure}


%% \begin{figure}
%% \centering
%% \subfigure[Void and perimeter]{
%% 	 \includegraphics[width=4cm]{figures/PerimeterBots1}
%%     \label{concave:VoidPerimeter1}
%% }
%% \subfigure[Multiple perimeters]{
%% 	 \includegraphics[width=6.5cm]{figures/PerimeterBots2}
%%     \label{concave:VoidPerimeter2}
%% }
%% \caption{Swarm perimeters and voids}
%% \label{fig:SwarmVoids}
%% \end{figure}

There is an exceptional circumstance that must be considered in perimeter detection. This is covered in Section~\ref{section:PerimeterErrorLocalisation}. Figure~\ref{fig:FullPerimeter1} is a screen shot from the simulator showing both perimeter types detected. The algorithm does not distinguished between the types. 

\begin{figure}
\begin{center}
\includegraphics[width=7cm]{figures/FullPerimeter}
\end{center}
\caption[Swarm with full perimeter detection]{Swarm with full perimeter detection (\textit{screen shot from simulator})\label{fig:FullPerimeter1}}
\end{figure}

The full-perimeter algorithm allows a predictable subset of agents to be identified. This subset can be used to influence the overall direction of the swarm. The full-perimeter detection algorithm detects similar agents to the basic-count algorithm but also identifies `indented' agents that the basic-count algorithm ignores. The basic-count algorithm identifies these agents as having a neighbour count beyond the threshold.

\subsection{Full-perimeter coordinator detection}\label{sec:PerimeterAgentDetection} 
The process of detecting a perimeter agent is based upon identifying when the agent in not surrounded by interconnected neighbours~(Figure~\ref{reduced:Perimeter1}). The process has several conditional checks that detect the status of an agent, each step is discussed below. 

\begin{figure}
\begin{center}
\includegraphics[width=6cm]{figures/Perimeter1}
\end{center}
\caption{Complex multifaceted agents \label{reduced:Perimeter1}}
\end{figure}

The first check is a short circuit count of the number of neighbours. This is the same process used to the basic-count algorithm. If an agent has $\leq 4$ neighbours and the swarm parameters are for a hexagonal swarm configuration then the agent is a perimeter agent and therefore a coordinator. This identification process is shown in~Figure~\ref{SmallNeighbourCount}. 

\begin{figure}
\begin{algorithmic}[1]
\Procedure{NeighbourCount}{$b$}
\If{$|nbr(b)| \leq 4$}
   \State\textbf{return} $True$
\EndIf
\State\textbf{return} $False$
\EndProcedure
\end{algorithmic}
\caption{SmallNeighbourCount}
\label{SmallNeighbourCount}
\end{figure}

If the short circuit neighbour count check fails then further conditions must be checked. The additional checks require a dictionary of agent/angular values to be generated~(Figure~\ref{eq:ConcaveVoidPhysics1}). Algorithm~\ref{algo:getNeighbourAngles} shows how the dictionary of agent/angle values are produced.   

\begin{center}
\begin{equation}‎
\label{eq:ConcaveVoidPhysics1}
S_b \buildrel \Delta \over =‎ \{(b',\angle\{(b'~b~b^0)) : b' \in nbr(b)\}
\end{equation}‎
\end{center}

Figure~\ref{eq:ConcaveVoidPhysics1} generates the dictionary set of all the neighbours along with an angle that each of the agent's neighbour's make with the first detected neighbour.
%% 
%% \begin{center}
%% \begin{equation}‎
%% \label{eq:ConcaveVoidPhysics2}
%% G_b \buildrel \Delta \over =‎ gap(S_b,\angle<180^\circ)
%% \end{equation}‎
%% \end{center}

Algorithm \ref{algo:getNeighbourAngles} shows the logic to produce the sorted neighbour/angle dictionary. $sort(.)$ sorts the dictionary set generated in~Equation~\ref{eq:ConcaveVoidPhysics1} by ascending angle to produce a dictionary of neighbour agents with their relative angle to the first detected neighbour as shown in~Figure~\ref{reduced:Perimeter1}.

\begin{figure}
\begin{algorithmic}[1]
\Procedure{NeighbourAngle}{$b$}
\State $angles \leftarrow \emptyset$
\For{$b^{'}\in b.neighbours$}
	\If{$b.neighbours[0] == b^{'}$}
      \State $angles[b^{'}] = 0$
	\Else
		\State $newAngle = b.getAngle(b.neighbours[0], b^{'})$	   \State $angles[b^{'}] = newAngle$
	\EndIf
\EndFor
\State \textbf{return}{$sort(angles)$} 
\EndProcedure
\end{algorithmic}
\caption{NeighbourAngle: Sorted by angle}
\label{algo:getNeighbourAngles}
\end{figure}

Using the angular dictionary from Algorithm~\ref{algo:getNeighbourAngles} it is possible to identify if adjacent neighbours can detect each other. If the agent is within all of its neighbours boundary then it is not on the perimeter~(Algorithm~\ref{algo:checkVisibility}). 

As the agents are monolithic all agents have the same field effects the `visibility' of two neighbours can be determined. The angle and distance of each neighbour pair and the angle they create allows cosine rule to be used to calculate the distance the neighbours are apart as shown in~Equation~\ref{eq:CosineRule1} and~Figure~\ref{reduced:Triangulate}. The distance is then checked against the neighbour range field effect. If the distance is $\leq N_b$ where $N_b$ is the \textit{neighbour field} then the agent can assume the neighbours have `sight' of each other. 

\begin{figure}
\begin{center}
\includegraphics[width=4.5cm]{figures/Triangulate}
\end{center}
\caption{Neighbour visibility\label{reduced:Triangulate}}
\end{figure}

\begin{equation}\label{eq:CosineRule1}
z = \sqrt{x^2 + y^2 - 2xy~\cos(\theta)}
\end{equation}‎

The full visibility check~(Algorithm~\ref{algo:checkVisibility}) takes each pair in turn and using the cosine rule~(Equation~\ref{eq:CosineRule1}) checks for a `visibility gap'. 

\begin{figure}
\begin{algorithmic}[1]
\Procedure{NeighbourAngle}{$b,angles$}
\For{$i \leftarrow 0$ to $size(angles)-1$}
	\If{i == size(angles)-1}
		\If{$cosrule(b,angles[size(angles)-1][0],angles[i][0]$}
			\State \textbf{return} $True$ 
   	\EndIf
	\ElsIf{$cosrule(b,angles[i + 1][0],angles[i][0]$}
		\State \textbf{return} $True$ 
	\EndIf
\EndFor
\State \textbf{return} $False$ 
\EndProcedure
\end{algorithmic}
\caption{CheckVisibility}
\label{algo:checkVisibility}
\end{figure}

%% \begin{algorithm}
%% \DontPrintSemicolon
%% \SetAlgoLined
%% \caption{CheckVisibility}
%% \KwData{b,angles}
%% \For{$i \leftarrow 0$ \KwTo $size(angles)-1$}{
%% 	\eIf{i == size(angles)-1}{
%% 		\If{$cosrule(b,angles[size(angles)-1][0],angles[i][0]$}{
%%    		\KwRet{True}
%%    	}
%% 	}
%% 	{\If{$cosrule(b,angles[i + 1][0],angles[i][0]$}{
%% 			\KwRet{True}
%% 		}
%% 	}
%% }
%% \KwRet{False}
%% \label{algo:checkVisibility}
%% \end{algorithm}

There is one exception to the neighbour visibility check. Due to compression of the swarm, which can be caused by an initial deployment configuration~(Figure~\ref{fig:SampleSwarm200-1} page \pageref{fig:SampleSwarm200-1}) or when an obstacle is in the path of the swarm, the agent's neighbours are able to `see' other neighbours but a pair of sequential neighbours could create an angle $> 180^\circ$ as shown in~Figure~\ref{reduced:Perimeter2}. In this case the agent is on the outside of the enclosed neighbour space, the agent is therefore on a perimeter. 

\begin{figure}
\begin{center}
\includegraphics[width=5.5cm]{figures/Perimeter2}
\end{center}
\caption{Convex multifaceted agents \label{reduced:Perimeter2}}
\end{figure}

This phenomenon requires the detection process to identify the angles that all the agents create from an arbitrary point, in this case the first identified neighbour. The neighbours must then be checked to determine if any neighbour pair create an angle $> 180^\circ$~(Figure~\ref{reduced:Perimeter1}~Algorithm~\ref{algo:checkConvex}). This process includes a short circuit in that as soon as a gap is found the check terminates. 

\begin{figure}
\begin{algorithmic}[1]
\Procedure{CheckConvex}{$angles$}
\For{$i \leftarrow 0$ to $size(angles)-1$}
	\If{i == size(angles)-1}
		\If{$360 - angles[loop][1] \geq 180$}
			\State \textbf{return} $True$ 
   	\EndIf
	\ElsIf{$angles[loop + 1][1] - angles[loop][1] \geq 180$}
		\State \textbf{return} $True$ 
	\EndIf
\EndFor
\State \textbf{return} $False$ 
\EndProcedure
\end{algorithmic}
\caption{CheckConvex}
\label{algo:checkConvex}
\end{figure}

%% \begin{algorithm}
%% \DontPrintSemicolon
%% \SetAlgoLined
%% \caption{CheckConvex}
%% \KwData{angles}
%% \For{$i \leftarrow 0$ \KwTo $size(angles)-1$}{
%% 	\eIf{i == size(angles)-1}{
%% 		\If{$360 - angles[loop][1] \geq 180$}{
%%    		\KwRet{True}
%%    	}
%% 	}{
%% 		\If{$angles[loop + 1][1] - angles[loop][1] \geq 180$}{
%% 			\KwRet{True}
%% 		}
%% 	}
%% }
%% \KwRet{False}
%% \label{algo:checkConvex}
%% \end{algorithm}

The complete perimeter detection algorithm using this `cyclic-angular-neighbour-check' methodology is show in~Algorithm~\ref{algo:checkPerimeter}. The first part of the algorithm is the short circuit check~(\textit{SmallNeighbourCount(b)}). This is only followed by the visibility check (\textit{CheckVisibility(b,angles)}) if the short circuit fails. If the visibility check is confirmed, which is another short circuit method, the convex check is carried out~(CheckConvex(angles)). This sequence ensures the minimum computational overhead for the agent check. 

\begin{figure}
\begin{algorithmic}[1]
\Procedure{CheckPerimeter}{$b,S$}
\If{SmallNeighbourCount(b,S)}
	\State \textbf{return} $False$ 
\EndIf
\State $angles = NeighbourAngle(b)$
\If{CheckVisibility(b,angles)}
	\If{CheckConvex(angles)}
		\State \textbf{return} $True$ 
	\EndIf
\EndIf
\State \textbf{return} $False$ 
\EndProcedure
\end{algorithmic}
\caption{CheckPerimeter}
\label{algo:checkPerimeter}
\end{figure}

%% \begin{algorithm}
%% \DontPrintSemicolon
%% \SetAlgoLined
%% \caption{CheckPerimeter}
%% \KwData{$b,S$}
%% \If{SmallNeighbourCount(b,S)}{
%% 	\KwRet{True}
%% }
%% $angles = NeighbourAngle(b)$\;
%% \If{CheckVisibility(b,angles)}{
%% 	\If{CheckConvex(angles)}{
%% 		\KwRet{True}
%% 	}
%% }
%% \KwRet{False}
%% \label{algo:checkPerimeter}
%% \end{algorithm}

\subsubsection{Perimeter detection errors\label{section:PerimeterErrorLocalisation}}
With the proximity of the agents needing to be hexagonally connected and the requirement to eliminate inter-agent communications to allow for arbitrary sized swarms, there is the possibility of a localised perimeter detection algorithm error. When a swarm is compressed a localised anomaly can arise where agents are in a hyper-connected structure on a perimeter. When this anomaly occurs the proposed algorithm will produce a false positive result for the affected agents. 

\begin{figure}
\begin{center}
\includegraphics[width=5cm]{figures/PerimeterError1}
\end{center}
\caption{Perimeter detection error\label{reduced:CompressedRangeError}}
\end{figure}

Figure~\ref{reduced:CompressedRangeError} shows two agents $b^{'}$ and $b^{''}$. The agents have visibility of each other as shown by the green field effects. The agents can also `see' another agent beyond their immediate neighbour. Agent $b^{'}$ is influenced by $b^{''}$ and neighbour 1. Agent $b^{'}$ is influenced by $b^{''}$ and neighbour 5. Due to these interactions both agents could calculate that they are surrounded by neighbours and are therefore not a part of the perimeter. The visibility issue is indicated by the red lines between $b^{''}$ and 5, and $b^{'}$ and 1. Neighbours 1 and 5 have no visibility of each other. Due to the connectivity shown in red there is a possibility of a failure in full perimeter detection as agents 5 and 1 cannot detect each other. 

The possible pathways that could be detected as the perimeter are: $5 \rightarrow b^{'} \rightarrow 1$, $5 \rightarrow b^{''} \rightarrow 1$. A third alternative of $5 \rightarrow b^{'} \rightarrow b^{''} \rightarrow 1$ could also be used but it is not strictly a true perimeter route as the previous routes are shorter.  

This problem can be resolved fully by introducing a communications channel that would allow the affected agents to negotiate a resolution to chose one of the shorter pathways~\cite{MD:09}, as there is no communications available this is not an option. In this thesis the error is limited to a very specific set of circumstances which will only occur during the initial expansion phase or during obstacle avoidance. The algorithm described in~Section~\ref{sec:PerimeterAgentDetection} selects both agents as being perimeter agents therefore the problem can is resolved by using the pseudo-perimeter ($5 \rightarrow b^{'} \rightarrow b^{''} \rightarrow 1$) ensuring a continuous perimeter is detected. 

The screen shot below shows the algorithm resolving the issue to the pseudo-perimeter in the simulator~(Figure~\ref{reduced:PerimeterAnomaly}).

\begin{figure}
\begin{center}
\includegraphics[width=5cm]{figures/PerimeterAnomaly}
\end{center}
\caption{Simulator perimeter detection\label{reduced:PerimeterAnomaly}}
\end{figure}

\subsubsection{Perimeter and void detection}\label{sec:PerimeterVoidDetection} 
The focus of this thesis is the control of arbitrary sized swarms. The identification of the inner and outer perimeters would require a communications mechanism to determine which type of perimeter an agent was a part of~\cite{ZAPS:07,MD:09}. A mean angle $< 180^\circ$ would indicate a void. A mean angle $> 180^\circ$ would indicate an outer perimeter which may be enclose inside a swarm as shown in~Figure~\ref{concave:VoidPerimeter2} on page \pageref{concave:VoidPerimeter2}.  

The communications architecture would prevent swarms of an arbitrary size from being coordinated due to the $O(n^{2})$ message propagation time factor~(Figure~\ref{methods:MessagePropogation})~\cite{SHA:07}. It should be noted however that introducing the communications layer would increase the potential functionality of the swarm and may have practical applications in other scenarios where smaller swarms are appropriate. 

A further issue of introducing a communications infrastructure would be the increase in the energy usage of the swarm. Identification of the perimeter type is therefore not practical in context of this thesis.

\subsection{Baseline/full perimeter comparison\label{section:compareBaselineFullPerimeter}}
Figures~\ref{reduced:BaselineFullPerimeterMag1} and \ref{reduced:BaselineFullPerimeterDist1} show the comparisons of the baseline swarm against the goal based swarm using full perimeter detection. 

Both Figures~\ref{reduced:BaselineFullPerimeterMag1} and \ref{reduced:BaselineFullPerimeterDist1} show that the settling period of the swarm from the chaotic state occurs at a very similar rate to the baseline but the swarm does not settle into a condition that has the same stability as the baseline. This deviation can be expected as the algorithms selection criteria is such that when the swarm is highly compressed there will be a limited number of perimeter agents effecting the directional bias of the swarm and the majority of internal logic will be the \textit{interaction vectors} expanding the swarm.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineFullPerimeterMag1}
\end{center}
\caption{Baseline/Full perimeter magnitude comparison\label{reduced:BaselineFullPerimeterMag1}}
\end{figure}

Figure~\ref{reduced:BaselineFullPerimeterMag1} shows the magnitude metric for the simulation. Up to the point where the magnitude reaches zero ($\approx$ 4.8 seconds / 48 cycles) the swarm is undergoing expansion and the \textit{inter-agent vectors} have a higher repulsive magnitude. Up to this point it is not possible to determine if the swarm is a cohesive entity. Once the \textit{inter-agent vector magnitude} becomes positive the swarm is known to be cohesive. Once the \textit{interaction vectors magnitudes} subside the directional bias from the coordinator agents \textit{destination vectors} will influence the swarm's direction. 

Once the swarm has completed its expansion the swarms interacting vectors stabalise to an optimum level for the swarm environment parameters. The level of interaction between the vectors produces an increase in the jitter compared to the baseline. This change is induced by the coordinators \textit{destination vectors}.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineFullPerimeterDist1}
\end{center}
\caption{Baseline/Full perimeter distance comparison\label{reduced:BaselineFullPerimeterDist1}}
\end{figure}

Figure~\ref{reduced:BaselineFullPerimeterDist1} shows the swarm expanding as the average distance increases. The expansion eventually settles to a level where the agents are separated but the average distribution is less than the baseline. The reduction in the inter-agent distances is caused by a change induced by the \textit{destination vectors} of the coordinators reducing the repulsion effect. The level of jitter is also greater than the baseline again this is caused by the \textit{destination vectors} preventing the non-coordinator agents from moving towards an equilibrium state.

\subsection{Complex Multifaceted Swarm (full-perimeter) - Simulation}
The simulation shows that once the swarm has stabilised the majority of agents are still disrupted by the introduction of the \textit{destination vectors}. This results in the swarm's agents having to move more to maintain the hexagonal structures. The agents that are on the perimeter tend to have 3 or more neighbours. 

The experiment demonstrates that the perimeter detection algorithm is a practical technique to apply to the detection of a swarm subset to reduce GPS usage. However the environmental parameters the impact of the \textit{destination vectors}create a high level of jitter within the swarm.

\section{Baseline and effect comparison\label{section:compareBaselineAll1}}
To compare the three algorithms and their effects the metrics applied. The internal movement (jitter), the terminal speed of the centroid of the swarm and the effect on the path of the swarm are considered. 

Analysing the path and speed of a swarm requires the centroid to be identified~\cite{HAY:08,VG:05,GP:02,GP:04,GP:04a,GP:05,GP:11}. The centroid is then tracked over time as the swarm progresses to its a goal~(Equation~\ref{eq:Centroid1}).

The centroid of the swarm is determined by taking the coordinate position of each agent and calculating the mean of the $x$ and $y$ positions.

\begin{equation}\label{eq:Centroid1}
C_s = \frac{1}{|S|}\mathlarger{\sum_{b' \in S}} b'
\end{equation}‎

Equation~\ref{eq:Centroid1} calculates the coordinates for the centre of the swarm ($C_s$) as an $x,y$ coordinate where $S$ is the swarm and $b^{'}$ is the coordinate $x,y$ for each agent and $|S|$ is the number of agents in the swarm.

Comparing swarms with these metrics generates a fuller understanding of the effects the algorithms and allows suitable applications to be identified.

\subsection{Internal movement comparison\label{section:stabilityComparison1}}
Figures \ref{reduced:BaselineAllDist1}, \ref{reduced:BaselineAllMag1}, \ref{reduced:BaselineAllDist2}, and \ref{reduced:BaselineAllMag2} identify the jitter based on distance and the \textit{inter-agent vector magnitudes} for the coordintion algorithms and the baseline. Both the metrics show that as the number of coordinator agents increases the jitter increases. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllDist1}
\end{center}
\caption{Baseline distance comparison\label{reduced:BaselineAllDist1}}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllDist2}
\end{center}
\caption{Baseline distance comparison\label{reduced:BaselineAllDist2}}
\end{figure}

Figure~\ref{reduced:BaselineAllDist2} show that the average distance between the agents is reduced when less coordinators are used. This indicates that for the same sized swarm with the same field effects the area covered by the swarm is reduced as the effect of the repulsion is hampered by the coordinators. It also shows that the time taken for the swarm to stabilises is increased due to the \textit{destination vectors} impacting on the agents ability to produce stable structures~(Figure~\ref{reduced:BaselineAllDist1}). 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllMag1}
\end{center}
\caption{Baseline magnitude comparison\label{reduced:BaselineAllMag1}}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllMag2}
\end{center}
\caption{Baseline and magnitude comparison\label{reduced:BaselineAllMag2}}
\end{figure}

Figures \ref{reduced:BaselineAllMag1} and \ref{reduced:BaselineAllMag2} highlight that a highly compressed swarm's magnitude, indicated by a negative magnitude, will overwhelm most of a swarms activity. This can be expected due to the size of the magnitudes that are affecting the swarm's movement. When all agents in a swarm are coordinators the directional effect can break through the highly cohesive stabilising vectors but this increases the level of jitter making the swarm's internal movement less predictable.

The directional algorithm that introduces the least amount of jitter is the basic-count algorithm. The basic-count algorithm is also the simplest of the multi-faceted algorithms to implement with a minimal computational overhead for the agents. 

Figure~\ref{reduced:BaselineAllMag2} shows a closer view of the swarms following the stabilisation period between 17.5s and 20s. The basic-count algorithm is produces the least disruption to the agents and has the highest average \textit{inter-agent vector magnitude} indicating the swarm has a higher tendency to remain cohesive with the widest distribution. This effect is caused by the increase in the cohesion effect when the agents are more distant. This demonstrates that the algorithm produces a swarm that covers a greater area. The increased area coverage is confirmed by Figure~\ref{reduced:BaselineAllDist2} which shown the greatest average inter-agent distance. The `all-agent' algorithm has the smallest resultant \textit{inter-agent vector magnitude} indicating that the swarm is more highly compressed (more repulsion is in operation). This is corroborated by the inter-agent distribution shown in~Figure~\ref{reduced:BaselineAllDist2}.

\subsection{Swarm GPS utilisation\label{section:compareGPSUages1}}
The multi-faceted algorithms that are defined above create subsets of coordinator agents for the application of a \textit{destination vector} bias of a swarm. These subsets can be identified to identify the GPS usage in the swarm at each time cycle ($t$). This allows a profile of the algorithms coordinator role identification process to be isolated to identify the level of GPS utilisation in the swarm.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmPerimeter1}
\end{center}
\caption{200 agent swarm GPS Usage\label{fig:SwarmPerimeter1}}
\end{figure}

Figure~\ref{fig:SwarmPerimeter1} shows the development of the GPS utilisation of the swarm using the `all-agent' coordination and the perimeter detection (multi-faceted) algorithms over the period of a 60s simulation. 

\subsubsection{All agent GPS utilisation\label{section:SwarmPerimeter2}}
Figure~\ref{fig:SwarmPerimeter1} shows the `all-agent' algorithm as a simple flat constant of 200 agents which is 100\% of the swarm's agents. The directional bias is therefore constant throughout the simulation. 

\subsubsection{Basic-count GPS utilisation\label{section:SwarmPerimeter3}}
In Figure~\ref{fig:SwarmPerimeter1} the `basic-count' algorithm is shown in blue. Due to the swarm being compressed the basic-count effect is initially limited. There are no coordinators identified at $t=0$. This is due to the compression of the agents in the initial deployment. As the simulation progresses the chaotic stage expands the swarm and disperses the agents such that each agent develops less neighbours. The coordinator detection algorithm then begins to identify a subset on the perimeter. This process continues and eventually settles, shown by the plateau in the graph. Figure~\ref{fig:SwarmPerimeter1} shows there is a slight change in the swarm structure at 8 seconds, this is due to anomalies in the swarm being corrected by the effect of the cohesion and repulsion field effects. Once the anomalies percolate out of the swarm the structure stabalises and the number of coordinators stops fluctuating.

\subsubsection{Full perimeter GPS utilisation\label{section:SwarmPerimeter4}}
The full perimeter detection algorithm starts with a subset immediately as shown in green in Figure~\ref{fig:SwarmPerimeter1}. This is due to the algorithm always detecting a full perimeter based on neighbour visibility. This has an immediate effect on the swarm as there is always a degree of \textit{destination vector magnitude} influence on the swarm, even during the chaotic expansion phase~Figure~\ref{reduced:SwarmPropagationPathComparison1}. However, the \textit{interaction vector magnitudes} are much larger than the \textit{destination vector magnitude} so the progression towards the goal is hampered and the path of the swarm is erratic. The introduction of the \textit{destination vector} influence from the very begin also disrupts the swarms expansion and increases the duration of the chaotic period. As the swarm expands the algorithm detects more agents as coordinators as the number of perimeter agents increases.

\subsection{Swarm path propagation comparison\label{section:compareBaselineAll1}}
All algorithms do eventually settle to a stable structure (for their environment parameters) with agents distributed in lattice structures. The time taken for each algorithm to achieve their stable distribution varies. This is due to the level of influence the directional bias has on the swarm. Figure~\ref{tab:GPSUsage} shows the settled coordinator distributions at 12s into the simulation.

\begin{table}
\begin{center}
\begin{tabular}{| p{1.5cm} | c | c | p{3cm} |}
\hline
GPS Model & Bots GPS & \% usage & Description \\ \hline
All-agents & 200 & 100\% & All agents are coordinators \\ \hline
Basic-count & 40 & 20\% & Minimal counting algorithm\\ \hline
Full perimeter & 72 & 36\% & Void detection and perimeter (capable of supporting void reduction)\\  \hline
\end{tabular}\caption{Swarm GPS enabled coordinators} \label{tab:GPSUsage}
\end{center}
\end{table}

The three algorithms take different amounts of time to stabalise~(Figure~\ref{fig:SwarmPerimeter1}) this has an impact on how long it takes each of the algorithms to impact the swarms movement towards the destination. This effect can be seen in~Figure~\ref{reduced:SwarmPropagationPathComparison1} that shows the paths that each algorithm produces. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmPropagationComparison1}
\end{center}
\caption{Swarm propagation path comparison\label{reduced:SwarmPropagationPathComparison1}}
\end{figure}

Figure~\ref{reduced:SwarmPropagationPathComparison1} shows the initial expansion phase of the swarm from deployment. Figure~\ref{reduced:SwarmPropagationPathComparison2} shows the paths for the full simulation runs and the baseline comparison.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmPropagationComparison2}
\end{center}
\caption{Swarm propagation path comparison\label{reduced:SwarmPropagationPathComparison2}}
\end{figure}

Using all agents as coordinators results in the swarm immediately moving in the direction of the destination. The full perimeter detection has a limited effect on the direction of travel until the internal vectors start to balance and the internal magnitudes can be affected by a \textit{destination vectors} at which point the swarm travels in the direction of the destination. The basic-count algorithm stabilises and then moves towards the destination in a similar manner to the full perimeter except in the initial compressed chaotic stage the basic-count algorithm develops in the same manner as the baseline swarm where there are no coordinators. These experimental results demonstrate that reducing the GPS utilisation has two effects on the swarms propagation. Firstly it is possible to reduce the number of GPS sensors required to coordinate a swarm and it is possible to manage the `jitter' while applying a directional bias on a swarm using \textit{destination vectors}. 

The effect of the algorithms on the stabilisation period can be seen in~(Figure~\ref{reduced:SwarmPropagationPathComparison3}) which shows the swarm paths at the end of the 60 seconds simulation period. The relative positions shows the distances that the swarm is able to travel while employing the three algorithms, this is based on the swarm centroid. The baseline centroid path shows that without a \textit{destination vector} being applied the swarm's centroid moves but it is based upon the \textit{interaction vectors} only and there is no directional bias.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmPropagationComparison3}
\end{center}
\caption{Swarm traversal at end of 60s run\label{reduced:SwarmPropagationPathComparison3}}
\end{figure}

\subsection{Speed of Swarm (Based on centroid)}
To determine the speed a swarm is travelling a single reference point needs to be identified. A swarm's speed is measured based upon the position of its centroid, as discussed by Gazi and Passino~\cite{GP:04, GP:02}.

The speed at which the swarm travels is calculated as the distance the centroid moves~(Figure~\ref{eq:SwarmDistance1}) over a set time~(Figure~\ref{eq:SwarmSpeed1}). Figure~\ref{eq:SwarmDistance1} shows the formulae for the distance a swarm has travelled over a set period of time, $t \rightarrow t^{1}$ where $d$ is the distance the centroid has travelled, $x,y$ is the centroid of the swarm and $t$ is time.

\begin{equation}\label{eq:SwarmDistance1}
d = \sqrt{(x_{t}-x_{t^1})^2+(y_{t}-y_{t^1})^2}
\end{equation}‎

\begin{equation}\label{eq:SwarmSpeed1}
S_s = \frac{d}{n}
\end{equation}‎

Equation~\ref{eq:SwarmSpeed1} shows how the speed is calculated based on the distance in Equation~\ref{eq:SwarmDistance1}. $S_s$ is the speed of the swarms centroid and $n$ is the number of time increments.

Once the swarm has stabilised it migrates towards the destination. Each of the algorithms has an effect on how many coordinators are used to control the direction of the swarm~(Figure~\ref{fig:SwarmPerimeter1}). The impact of the number of coordinators is expected to affect the propagation speed of the swarm towards its destination. Based upon the final positions of the swarms over the last 20 seconds of their simulations it is shown that there was only a marginal impact on the speed of the swarm once stabilised~(Figure~\ref{fig:SwarmSpeed1}). The difference in the algorithms only affects the time it takes the swarm to stabilise to the level that the \textit{destination vectors} can influence the swarms movement.

The results also show a reduction in energy usage (GPS usage) is possible with minimal effect on the overall speed of the swarm (taken from the centroid). 

Although the agents within the swarm have travelled the same distances the overall path of swarms has been affected~(Table~\ref{tab:SwarmSpeed2}).

The time frame for the results in~Tables~\ref{tab:SwarmSpeed1},~\ref{tab:SwarmSpeed2}~and~\ref{tab:SwarmSpeed3} are for a time slice from 40~-~60~seconds in the simulation.

\begin{table}
\begin{center}
\begin{tabular}{| l | l |}
\hline
GPS Model & Start \\ \hline
All-agents & (922.5254184933, 379.965865509344) \\ \hline
Basic-count & (828.5991571583, 433.5750489635) \\ \hline
Full perimeter & (848.1131820415, 410.9739402922) \\ \hline
\end{tabular}\caption{Swarm centroid after stabilisation (40s)} \label{tab:SwarmSpeed1}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{| l | l |}
\hline
GPS Model & End  \\ \hline
All-agents & (1294.5940641812, 233.788749492987) \\ \hline
Basic-count & (1201.4534856023, 289.7373900729) \\ \hline
Full perimeter & (1218.1290381962, 260.3440891182)\\ \hline
\end{tabular}\caption{Swarm centroid after stabilisation (60s)} \label{tab:SwarmSpeed2}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{| l | l | l |}
\hline
GPS Model & Distance & Speed \\ \hline
All-agents &  399.7534569593 & 19.987672848 \\  \hline
Basic-count & 399.6368631077 & 19.9818431554 \\ \hline
Full perimeter & 399.5010461444 & 19.9750523072 \\  \hline
\end{tabular}\caption{Swarm distance and speed after stabilisation (40s-60s)} \label{tab:SwarmSpeed3}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{| p{1.2cm} | l | l |}
\hline
GPS Model & End & Distance \\ \hline
All-agents & (1294.5940641812, 233.788749492987) & 588.5813143506\\ \hline
Basic-count & (1201.4534856023, 289.7373900729) & 696.0606134399\\ \hline
Full Perimeter & (1218.1290381962, 260.3440891182) & 669.4489951522\\ \hline
\end{tabular}\caption[Distance to destination after run]{Distance to destination after run \textit{(end = [1841,15])}}\label{tab:SwarmDistanceEnd}
\end{center}
\end{table}

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmSpeed1}
\end{center}
\caption{200 agent swarm terminal speed (over 20s period)\label{fig:SwarmSpeed1}}
\end{figure}

\subsection{Alternate weightings for directional bias}\label{sec:AlternateBias1}
The overall effect of the directional bias is effected by the number of coordinator agents in a swarm. Increasing the bias effects the jitter therefore balancing the weighting should have a positive effect in reducing the jitter.

The impact of the bias can be seen in the effect it has upon the number of neighbours an agent has during the path propagation.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmNeighbourCount}
\end{center}
\caption{Neighbour count effect from \textit{destination vectors}\label{fig:SwarmNeighbourCount}}
\end{figure}

Figure~\ref{fig:SwarmNeighbourCount} shows that for each of the algorithms the lattice effect (determined by neighbour count) takes longer to settle the more coordinators there are. In the case of the `all agent' coordinated swarm the agents are affected most significantly and therefore exhibit the high variation in magnitudes and distances.

The coordinator statistics demonstrates~Table~\ref{tab:GPSUsage} the weighting of the \textit{destination vectors} can be adjusted to produce an overall effect that is similar for each algorithm. If the weightings are adjusted taking the basic-count as the baseline goal-based swarm then the `all agents' and `full perimeter' algorithms can be weighted proportionally such that they have an overall \textit{direction vector magnitude} that is similar to the basic-count~Table~\ref{tab:GPSWeighting}. The effects of this is shown in Figures~\ref{fig:BaselineAll100-60-20-1}, \ref{fig:BaselineAllMag100-60-20-1}, and \ref{fig:SwarmNeighbourCountBalanced}

\begin{table}
\begin{center}
\begin{tabular}{| l | c | c | l |}
\hline
GPS Model & Bots GPS & \% Usage & Weighting \\ \hline
All-agents & 200 & 100\% & 20 \\ \hline
Basic-count & 40 & 20\% & 100 \\ \hline
Full perimeter & 72 & 36\% & 60 \\  \hline
\end{tabular}\caption{Swarm GPS proportional weighting}\label{tab:GPSWeighting}
\end{center}
\end{table}

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/SwarmNeighbourCountBalanced}
\end{center}
\caption{Neighbour count effect from balanced directional bias\label{fig:SwarmNeighbourCountBalanced}}
\end{figure}

Figure~\ref{fig:SwarmNeighbourCountBalanced} shows the effect reducing the \textit{destination vector magnitude} has on the swarm structure. The reduction brings the stability (jitter) of the three algorithms in line such that all the algorithms have a similar impact on the swarm producing swarms with more stable structures while still creating a goal based affect. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAll100-60-20-1}
\end{center}
\caption{Swarm distance analysis\label{fig:BaselineAll100-60-20-1}}
\end{figure}

Figure~\ref{fig:BaselineAll100-60-20-1} shows that the stabilisation periods of all the algorithms are much closer when the bias is proportional and the chaotic stage for all the algorithms appear to be reduced to be within the same time frame as the baseline.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAll100-60-20-2}
\end{center}
\caption{Swarm distance analysis\label{fig:BaselineAll100-60-20-2}}
\end{figure}

Figure~\ref{fig:BaselineAll100-60-20-2} shows that the resultant distance is also very close and the deviations are also very close. These results indicate that it is possible to reduce the internal jitter that is caused by an algorithm by adjusting the bias to weighting to be proportional to the number of agents that apply the directional influence.

Figures \ref{fig:BaselineAllMag100-60-20-1} and \ref{fig:BaselineAllMag100-60-20-2} show that the magnitude is also affected by the balancing of the directional bias. \ref{fig:BaselineAllMag100-60-20-1} shows the chaotic phase with the rapid expansion with the negative magnitude. This if followed by the stable period. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllMag100-60-20-1}
\end{center}
\caption{Swarm magnitude analysis\label{fig:BaselineAllMag100-60-20-1}}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllMag100-60-20-2}
\end{center}
\caption{Swarm magnitude analysis\label{fig:BaselineAllMag100-60-20-2}}
\end{figure}

Figure~\ref{fig:BaselineAllMag100-60-20-2} shows the balance with the inter-agent magnitude for all the algorithms at a very similar level. It is noticeable however that the basic-count algorithm still has the lowest jitter.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllPath100-60-20-1}
\end{center}
\caption{Swarm path analysis\label{fig:BaselineAllPath100-60-20-1}}
\end{figure}

Figure~\ref{fig:BaselineAllPath100-60-20-1} shows that with the adjusted weightings the swarms still progress towards their goal. Figure~\ref{fig:BaselineAllPath100-60-20-2} shows that the reduced weightings impact on the directional path of the swarm and all the algorithms are effected by the \textit{interaction vector magnitudes} during the initial expansion disrupting the swarm path.

Figure~\ref{fig:BaselineAllPath100-60-20-3} shows that all the algorithms produce a goal-based swarm with the `all-agent' algorithm furthest progress towards the end point. This is due to the instant directional influence of the algorithm. 

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllPath100-60-20-2}
\end{center}
\caption{Swarm path analysis\label{fig:BaselineAllPath100-60-20-2}}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figures/BaselineAllPath100-60-20-3}
\end{center}
\caption{Swarm path analysis\label{fig:BaselineAllPath100-60-20-3}}
\end{figure}

\subsection{Swarm coordination evaluation\label{reduced:coordinationEvaluation}}
Comparing the three metrics it is possible to determine the coordination effects based on the requirements of the swarm.

The resultant terminal speed of the swarm, based on the centroid, is minimally effected by the algorithm. 

The ability of the swarm to propagate towards a destination is hampered by reducing the number of coordinators as the stabilisation of the swarms structure reduces the \textit{destination vector magnitude}. The most effected algorithm is the basic-count algorithm which is unable to influence the swarm at deployment due to compression reducing the number of coordinators and lessening the aggregate \textit{destination vector magnitude}. The full perimeter algorithm creates a greater aggregate \textit{destination vector} more quickly than the basic-count algorithm, however the algorithm does induce additional jitter. The `all-agent' algorithm has an immediate aggregate \textit{destination vector magnitude} but this algorithm also induces jitter such that the hexagonal lattice start to fail.
 
Increasing the number of coordinators increases the amount of internal disturbance within the swarm which can affect a sensor array in terms of its ability to function efficiently. Adjusting the weighting of $k_d$ can improve this as discussed in~Section~\ref{sec:AlternateBias1}. The algorithm that is most improved by adjusting the weightings is the `all-agent' algorithm such that it allows the hexagonal lattice to form and still produces an immediate directional bias through the aggregate \textit{destination vectors}.  

The computational overhead of each of the algorithms differs only in the logic that is required for swarm coordination. The is no computation overhead for the `all-agents` algorithm. The computational requirements of the basic-count algorithm is a simple count of neighbours and the full perimeter requires sweeps of angles and visibility checks which may impact on processor speeds for implementation. 

The main energy difference between the algorithms is the use of the GPS sensor which is a high energy consumption device. Therefore for general purpose coordination the basic-count algorithm provides the lowest GPS energy requirement and also minimal computational overhead.

\section{Energy efficiency evaluation\label{reduced:EnergyReductionGPS}}
The effect of an algorithm also effects the amount of gross energy that is used by the swarm in creating the directional effect. If we consider different size physical agents the overall effect of the algorithm can impact on the practical use of the swarm.

The following evaluation is based on analysing the motor and GPS usage and ignores the energy consumption of sensors and agent processor units.

Reducing the number of GPS modules being used at any point in time will impact the overall use of energy by the swarm. Comparing current GPS modules it was found that on average GPS modules consume approximately 44mA, for a 3.3V GPS. This equates to approximately 145mW of power as given by Ohm's Law. 

%% \begin{equation}
%% \label{eq:wattage}
%% W = V * I
%% \end{equation}

The energy usage of a motor will depend upon the power requirements required for agent movement (dependant on agent size and weight). It is assumed that the agents will utilise an omni ball movement system to provide universal movement. Most omni ball systems utilise 3 motors to control the movement~(Figure~\ref{fig:OmniBall}), other configuration are possible such as the four wheeled omni directional wheelbase\cite{PD:06}.

\begin{figure}
\begin{center}
\includegraphics[width=6cm]{figures/OmniBall}
\end{center}
\caption{Omni ball motor arrangement \label{fig:OmniBall}}
\end{figure}

Three possible scenarios of different motor requirements are compared for possible energy savings.

The three scenarios are for 3A, 1A and 400mA motors.

The scenario assumes a GPS is being used in all the agents as shown in~(Table~\ref{tab:GPSUsage}) the energy consumption will be based on a swarm size of 200 agents.

\begin{table}
\begin{center}
%\fontsize{8}{8}\selectfont
\begin{tabular}{| r | r | r | r |}
\hline
Motor & Watts  & No GPS & With GPS \\ \hline
100mA &  0.33W &  0.99W & 1.1352W\\ \hline
1A    &  3.3W  &  9.90W & 10.0452W\\ \hline
3A    &  9.9W  & 29.70W & 29.8452W\\ \hline
\end{tabular}\caption{Energy consumption per agent} \label{tab:Energy1}
\end{center}
\end{table}

\begin{table}
%\fontsize{8}{8}\selectfont
\begin{center}
\begin{tabular}{| c | r | r | r |}
\hline
{\parbox{1.5cm}{\centering Motor}} & {\parbox{1cm}{\centering All\\100/0}} & {\parbox{1.5cm}{\centering Full\\36/64}} & {\parbox{1.5cm}{\centering Basic \\20/80}} \\ \hline
100mA &  227.04W &  208.4544W &  203.808W\\ \hline
1A    & 2009.04W & 1990.4544W & 1985.808W\\ \hline
3A    & 5969.04W & 5950.4544W & 5945.808W\\ \hline
\end{tabular}\caption{Energy consumption of swarm} \label{tab:Energy2}
\end{center}
\end{table}

\begin{table}
%\fontsize{8}{8}\selectfont
\begin{center}
\begin{tabular}{| c | r | r | r |}
\hline
{\parbox{1.5cm}{\centering Motor}} & {\parbox{1cm}{\centering All\\100/0}} & {\parbox{1,5cm}{\centering Full\\36/64}} & {\parbox{1.5cm}{\centering Basic \\20/80}} \\ \hline
100mA & 0\% & 8.186\% & 10.232\% \\ \hline
1A    & 0\% & 0.925\% &  1.156\% \\ \hline
3A    & 0\% & 0.311\% &  0.389\% \\ \hline
\end{tabular}\caption{Energy consumption of swarm} \label{tab:Energy3}
\end{center}
\end{table}

The tables above demonstrate the most effective savings in energy can be achieved by using smaller motors. This implies using smaller agents will provide the most appropriate platform to use GPS energy conservation. This efficiency saving falls in line with the current trend in using smaller agents in swarms as described by Mulgaonkar et al.~\cite{KV:16,MCK:15} who work as part of the research group at the University of Pennsylvania.

\section{Message Propagation Performance\label{methods:MessagePropogation}}
Many algorithms depend upon the propagation of messages throughout a swarm to determine many of the characteristics that allow it to be controlled~\cite{MD:09}. However message propagation has an ($O(n^2)$) propagation profile which effects the speed at which a swarm can react to characteristic changes~\cite{SHA:07}. This could be countered by a reduction in the speed that agents move within a swarm to counter the message propagation delays. 

The perimeter detection algorithms employed in this thesis have been reduced from ($O(n^2)$) to zero by limiting the agents information needs to simple proximity information from a sensor. This is a bio-inspired approach taken from the flocking of birds and shoaling of fish.

By reducing the message propagation to zero the scalability of the perimeter and void reduction algorithms are improved. Most research using message propagation techniques use swarms of at most 50 agents, as discussed this thesis is based upon the control of arbitrary sized swarms.

By localising the information requirements of an agent the storage requirements for message propagation are removed. Collating any characteristics of a swarm will require some form of local storage. As the messages propagate through a swarm more and more data is generated and data must be communicated and stored by each agent along with agent identifiers and some form of time stamp so data can be expired. In the case of the SenseSwarm algorithm this data is stored as a table of all agents, their coordinates, and a message id. This information is used to allows an agent to determine if it is at the lowest point in the swarm and therefore a perimeter agent~\cite{ZAPS:07}.

\subsection{SenseSwarm Message Propagation Comparison}
\begin{figure}
\begin{center}
\includegraphics[width=6cm]{figures/MessagePropogation1}
\end{center}
\caption{Message Propagation \label{methods:MessagePropogation1}}
\end{figure}

The SenseSwarm~\cite{ZAPS:07, APZDAMC:09, AZDPS:11} algorithm detects perimeters using a mechanism by which a lowest point in the swarm is identified. This is achieved by each agent collating a table of every agents coordinates. Each message consists of an `agent identifier' and a `message id'. The message is constructed by an agent and forwarded to each of its neighbours. If a message is received with the same `agent identifier' and `message id' as a previous message it is discarded. If the message is detected for the first time then the message is forwarded to all of the neighbour-agent's neighbours.

for $(n_1)$ the message propagation will be:-

$n_1 \to \{n_3, n_2, n_7\}$ \\
$n_3 \to \{n_2, n_5\}$\\
$n_7 \to \{n_2\}$\\
$n_2 \to \{n_5, n_4\}$\\
$n_5 \to \{n_6\}$\\
$n_4 \to \{n_6\}$\\

The SenseSwarm algorithm works by locating the lowest agent in the swarm and then that agent propagating a message left and right to next lowest neighbours to identify the swarms outer edge. 

\bibliographystyle{plain}
\bibliography{thesis}

\end{document}
